/**
 * Mock ERP provider that simulates a real Connect Plug (CPlug) API.
 *
 * All reference data (stocks, PDVs, categories, product catalog) is dynamically
 * generated by mock-store-generator based on the configured store size.
 * Inventories and counted items are persisted in localStorage (web) or in-memory.
 *
 * @see https://cplug.redocly.app/openapi — CPlug API reference
 */
import { Platform } from 'react-native';
import type { Contagem } from '@/entities/contagem/model/types';
import type { Estoque } from '@/entities/estoque/model/types';
import type { Pdv } from '@/entities/pdv/model/types';
import type {
  ErpProvider,
  ListInventoriesFilters,
  CreateInventoryParams,
  InventoryItem,
  EstruturaMercadologica,
} from './erp-provider-types';
import {
  simulateLatency,
  maybeThrowError,
  getMockConfig,
  PdvScenario,
} from './mock-config';
import {
  generateStoreData,
  drawInventoryItems,
} from './mock-store-generator';
import type { GeneratedStoreData, CatalogProduct } from './mock-store-generator';

// ─── Persistence layer (survives web page refresh) ───────────

const STORAGE_KEY_INVENTORIES = 'mock_inventories';
const STORAGE_KEY_ITEMS = 'mock_inventory_items';
const STORAGE_KEY_COUNTER = 'mock_count_id';
const STORAGE_KEY_PDVS = 'mock_pdvs';
const STORAGE_KEY_STORE_SIZE = 'mock_store_size';

/**
 * Simple read/write abstraction over localStorage (web) or in-memory fallback.
 * expo-secure-store is intentionally NOT used here — it's for credentials,
 * not bulk mock data.
 */
const storage = {
  get(key: string): string | null {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        return localStorage.getItem(key);
      }
    } catch {
      // ignore
    }
    return null;
  },
  set(key: string, value: string): void {
    try {
      if (Platform.OS === 'web' && typeof localStorage !== 'undefined') {
        localStorage.setItem(key, value);
      }
    } catch {
      // ignore — quota exceeded, private browsing, etc.
    }
  },
};

// ─── Dynamic store data (generated from config) ─────────────

let storeData: GeneratedStoreData | null = null;

/** Returns current store data, generating it if needed based on config. */
function getStoreData(): GeneratedStoreData {
  if (!storeData) {
    const { storeSize } = getMockConfig();
    // Check if store size changed since last persist
    const persisted = storage.get(STORAGE_KEY_STORE_SIZE);
    if (persisted && persisted !== storeSize) {
      // Size changed — regenerate everything
      clearAllStorage();
    }
    storeData = generateStoreData(storeSize);
    storage.set(STORAGE_KEY_STORE_SIZE, storeSize);
  }
  return storeData;
}

/** Force regeneration of store data (called on config change or reset). */
function invalidateStoreData(): void {
  storeData = null;
}

// ─── State management ────────────────────────────────────────

let mockCountId = 1;
const mockInventories: Map<string, Contagem> = new Map();
const mockInventoryItems: Map<string, InventoryItem[]> = new Map();
const mockPdvs: Map<string, Pdv> = new Map();

/** Persist current state to storage. Called after every mutation. */
function persist(): void {
  const inventoriesObj: Record<string, Contagem> = {};
  mockInventories.forEach((v, k) => { inventoriesObj[k] = v; });

  const itemsObj: Record<string, InventoryItem[]> = {};
  mockInventoryItems.forEach((v, k) => { itemsObj[k] = v; });

  const pdvsObj: Record<string, Pdv> = {};
  mockPdvs.forEach((v, k) => { pdvsObj[k] = v; });

  storage.set(STORAGE_KEY_INVENTORIES, JSON.stringify(inventoriesObj));
  storage.set(STORAGE_KEY_ITEMS, JSON.stringify(itemsObj));
  storage.set(STORAGE_KEY_COUNTER, String(mockCountId));
  storage.set(STORAGE_KEY_PDVS, JSON.stringify(pdvsObj));
}

/** Try to restore state from storage. Returns true if restored. */
function restore(): boolean {
  const rawInv = storage.get(STORAGE_KEY_INVENTORIES);
  const rawItems = storage.get(STORAGE_KEY_ITEMS);
  const rawCounter = storage.get(STORAGE_KEY_COUNTER);
  const rawPdvs = storage.get(STORAGE_KEY_PDVS);

  if (!rawInv) return false;

  try {
    const inventoriesObj = JSON.parse(rawInv) as Record<string, Contagem>;
    for (const [k, v] of Object.entries(inventoriesObj)) {
      mockInventories.set(k, v);
    }

    if (rawItems) {
      const itemsObj = JSON.parse(rawItems) as Record<string, InventoryItem[]>;
      for (const [k, v] of Object.entries(itemsObj)) {
        mockInventoryItems.set(k, v);
      }
    }

    if (rawCounter) {
      mockCountId = parseInt(rawCounter, 10) || mockCountId;
    }

    if (rawPdvs) {
      const pdvsObj = JSON.parse(rawPdvs) as Record<string, Pdv>;
      for (const [k, v] of Object.entries(pdvsObj)) {
        mockPdvs.set(k, v);
      }
    }

    return mockInventories.size > 0;
  } catch {
    return false;
  }
}

function clearAllStorage(): void {
  storage.set(STORAGE_KEY_INVENTORIES, '');
  storage.set(STORAGE_KEY_ITEMS, '');
  storage.set(STORAGE_KEY_COUNTER, '');
  storage.set(STORAGE_KEY_PDVS, '');
  storage.set(STORAGE_KEY_STORE_SIZE, '');
}

// ─── Seed data ───────────────────────────────────────────────

/** Seed PDVs from generated store data into in-memory map. */
function seedPdvs() {
  if (mockPdvs.size > 0) return;
  const data = getStoreData();
  for (const pdv of data.pdvs) {
    mockPdvs.set(pdv.id, { ...pdv });
  }
}

/**
 * Apply PDV scenario from mock config to all PDVs in-memory.
 * Called externally (from config screen) to bulk-change PDV statuses.
 */
export function applyPdvScenario(): void {
  seedPdvs();
  const { pdvScenario } = getMockConfig();
  const pdvList = Array.from(mockPdvs.values());

  pdvList.forEach((pdv, index) => {
    let status: 'ONLINE' | 'OFFLINE';
    if (pdvScenario === PdvScenario.ALL_ONLINE) {
      status = 'ONLINE';
    } else if (pdvScenario === PdvScenario.ALL_OFFLINE) {
      status = 'OFFLINE';
    } else {
      // mixed: odd-indexed PDVs are offline
      status = index % 2 === 0 ? 'ONLINE' : 'OFFLINE';
    }
    mockPdvs.set(pdv.id, {
      ...pdv,
      status,
      ultimoPing: status === 'ONLINE' ? new Date().toISOString() : pdv.ultimoPing,
    });
  });
  persist();
}

/**
 * Clear all mock data and re-seed from scratch.
 * Regenerates store data based on current config (store size).
 * Used by the mock config screen's "Reset data" action.
 */
export function resetMockData(): void {
  mockInventories.clear();
  mockInventoryItems.clear();
  mockPdvs.clear();
  mockCountId = 1;
  clearAllStorage();
  invalidateStoreData();
  seedInitialCounts();
  applyPdvScenario();
}

function seedInitialCounts() {
  if (mockInventories.size > 0) return;

  // Try to restore from persisted storage first
  if (restore()) {
    seedPdvs();
    return;
  }
  seedPdvs();

  const data = getStoreData();
  const config = getMockConfig();
  const stocks = data.stocks;

  // Seed 2 sample inventories on the first 2 stocks (or fewer if only 1)
  const seedStockIds = stocks.slice(0, 2).map((s) => s.id);
  const base = new Date();
  base.setDate(base.getDate() - 2);

  seedStockIds.forEach((estoqueId, i) => {
    const id = `00${mockCountId++}`;
    const dataInicio = new Date(base);
    dataInicio.setDate(dataInicio.getDate() + i);
    const dataFinalizacao = i === 1 ? new Date(base.getTime() + 86400000).toISOString() : undefined;
    const c: Contagem = {
      id,
      estoqueId,
      valorAConsiderar: 'VENDA',
      modalidadeContagem: i === 0 ? 'LOJA_ABERTA' : 'LOJA_FECHADA',
      dataInicio: dataInicio.toISOString(),
      status: i === 0 ? 'EM_ANDAMENTO' : 'FINALIZADO',
      dataFinalizacao,
      criadoEm: dataInicio.toISOString(),
      criadoPor: i === 0 ? 'mock-employee-1' : 'mock-manager-1',
      criadoPorNome: i === 0 ? 'Rafael Funcionário' : 'Claudio Gerente',
      ...(i === 1 && {
        finalizadoPor: 'mock-manager-1',
        finalizadoPorNome: 'Claudio Gerente',
        finalizadoEm: dataFinalizacao,
      }),
    };
    mockInventories.set(id, c);
    // Draw products from the generated catalog
    const items = drawInventoryItems(data.catalog, id, config.productCount);
    mockInventoryItems.set(id, items);
  });

  persist();
}

// ─── Factory ─────────────────────────────────────────────────

function createMockCount(params: CreateInventoryParams): Contagem {
  const id = `00${mockCountId++}`;
  const now = new Date().toISOString();
  const contagem: Contagem = {
    id,
    estoqueId: params.estoqueId,
    valorAConsiderar: params.valorAConsiderar,
    ...(params.estruturaMercadologicaId && { estruturaMercadologicaId: params.estruturaMercadologicaId }),
    ...(params.estruturaMercadologicaIds &&
      params.estruturaMercadologicaIds.length > 0 && { estruturaMercadologicaIds: params.estruturaMercadologicaIds }),
    ...(params.modalidadeContagem && { modalidadeContagem: params.modalidadeContagem }),
    dataInicio: now,
    status: 'EM_ANDAMENTO',
    criadoEm: now,
    criadoPor: 'mock-employee-1',
    criadoPorNome: 'Rafael Funcionário',
  };
  mockInventories.set(id, contagem);

  const data = getStoreData();
  const config = getMockConfig();
  // Filter catalog by selected categories if any
  const categoryFilter = params.estruturaMercadologicaIds ?? (params.estruturaMercadologicaId ? [params.estruturaMercadologicaId] : undefined);
  const items: InventoryItem[] = drawInventoryItems(data.catalog, id, config.productCount, categoryFilter);
  mockInventoryItems.set(id, items);
  persist();
  return contagem;
}

// ─── Provider ────────────────────────────────────────────────

export const mockErpProvider: ErpProvider = {
  async listStocks() {
    await simulateLatency();
    maybeThrowError();
    const data = getStoreData();
    return [...data.stocks];
  },
  async getStock(id: string) {
    await simulateLatency();
    maybeThrowError();
    const data = getStoreData();
    return data.stocks.find((s) => s.id === id) ?? null;
  },
  async listEstruturasMercadologicas() {
    await simulateLatency();
    maybeThrowError();
    const data = getStoreData();
    return [...data.categories];
  },
  async listInventories(filters: ListInventoriesFilters) {
    await simulateLatency();
    maybeThrowError();
    seedInitialCounts();
    let list = Array.from(mockInventories.values()).filter((c) => !c.excluidoEm);
    if (filters.estoqueId) list = list.filter((c) => c.estoqueId === filters.estoqueId);
    if (filters.status) list = list.filter((c) => c.status === filters.status);
    if (filters.dataInicio) {
      const from = new Date(filters.dataInicio).getTime();
      list = list.filter((c) => new Date(c.dataInicio).getTime() >= from);
    }
    if (filters.dataFim) {
      const to = new Date(filters.dataFim).getTime();
      list = list.filter((c) => new Date(c.dataInicio).getTime() <= to);
    }
    list.sort((a, b) => new Date(b.criadoEm).getTime() - new Date(a.criadoEm).getTime());
    return list;
  },
  async getInventory(id: string) {
    await simulateLatency();
    maybeThrowError();
    seedInitialCounts();
    const c = mockInventories.get(id);
    return c && !c.excluidoEm ? c : null;
  },
  async createInventory(params: CreateInventoryParams) {
    await simulateLatency();
    maybeThrowError();
    return createMockCount(params);
  },
  async updateInventory(id: string, patch) {
    await simulateLatency();
    maybeThrowError();
    const c = mockInventories.get(id);
    if (!c) throw new Error('Contagem não encontrada');
    const updated = { ...c, ...patch };
    if (patch.status === 'FINALIZADO') {
      updated.finalizadoPor = updated.finalizadoPor ?? 'mock-manager-1';
      updated.finalizadoPorNome = updated.finalizadoPorNome ?? 'Claudio Gerente';
      updated.finalizadoEm = updated.finalizadoEm ?? patch.dataFinalizacao ?? new Date().toISOString();
    }
    mockInventories.set(id, updated);
    persist();
    return updated;
  },
  async deleteInventory(id: string) {
    await simulateLatency();
    maybeThrowError();
    const c = mockInventories.get(id);
    if (!c) return;
    c.excluidoPor = 'mock-user';
    c.excluidoEm = new Date().toISOString();
    mockInventoryItems.delete(id);
    persist();
  },
  async listInventoryItems(inventoryId: string) {
    await simulateLatency();
    maybeThrowError();
    seedInitialCounts();
    return [...(mockInventoryItems.get(inventoryId) ?? [])];
  },
  async registerCountedQuantity(inventoryId: string, productId: string, qtdContada: number) {
    await simulateLatency();
    maybeThrowError();
    const items = mockInventoryItems.get(inventoryId);
    const item = items?.find((i) => i.produtoId === productId);
    if (!item) return { success: false, code: 'NOT_FOUND', message: 'Produto não encontrado' };
    item.qtdContada = qtdContada;
    item.dataHoraContagem = new Date().toISOString();
    persist();
    return { success: true };
  },
  async checkPdvOnline(inventoryId: string) {
    await simulateLatency();
    seedInitialCounts();
    const inv = mockInventories.get(inventoryId);
    if (!inv) return { ok: true };

    // Find all PDVs linked to this inventory's stock
    const linkedPdvs = Array.from(mockPdvs.values()).filter(
      (p) => p.estoqueId === inv.estoqueId
    );
    if (linkedPdvs.length === 0) return { ok: true };

    const offlinePdvs = linkedPdvs.filter((p) => p.status === 'OFFLINE');
    if (offlinePdvs.length > 0) {
      const names = offlinePdvs.map((p) => p.nome).join(', ');
      return {
        ok: false,
        message: `PDV(s) offline: ${names}. Conecte antes de registrar.`,
      };
    }
    return { ok: true };
  },
  async checkTransferenciasPendentes(_inventoryId: string, _productId: string) {
    await simulateLatency();
    return { ok: true };
  },

  // ─── PDV management ────────────────────────────────────────

  async listPdvs(filters?: { estoqueId?: string }) {
    await simulateLatency();
    maybeThrowError();
    seedInitialCounts();
    seedPdvs();
    let list = Array.from(mockPdvs.values());
    if (filters?.estoqueId) {
      list = list.filter((p) => p.estoqueId === filters.estoqueId);
    }
    return list;
  },
  async togglePdvStatus(pdvId: string) {
    await simulateLatency();
    maybeThrowError();
    seedPdvs();
    const pdv = mockPdvs.get(pdvId);
    if (!pdv) throw new Error('PDV não encontrado');
    const updated: Pdv = {
      ...pdv,
      status: pdv.status === 'ONLINE' ? 'OFFLINE' : 'ONLINE',
      ultimoPing: pdv.status === 'OFFLINE' ? new Date().toISOString() : pdv.ultimoPing,
    };
    mockPdvs.set(pdvId, updated);
    persist();
    return updated;
  },
};
